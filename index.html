<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <title>Medidor por Foto</title>

  <style>
    body { margin:0; font-family:-apple-system,system-ui,Arial; background:#0b0b0f; color:#fff; }
    header { padding:12px; background:#0f0f16; border-bottom:1px solid #222; }
    .box { background:#171722; border-radius:10px; padding:10px; margin-bottom:10px; }
    input[type="file"]{
      width:100%; padding:14px; font-size:18px; border-radius:10px; border:none;
      background:#2b5cff; color:#fff;
    }
    input[type="number"]{
      width:100%; padding:12px; font-size:18px; border-radius:10px; border:none; margin-top:6px;
    }
    button{
      width:100%; padding:14px; font-size:18px; border-radius:10px; border:none;
      margin-top:8px; background:#2b5cff; color:#fff;
    }
    #result{ font-size:20px; font-weight:700; margin-top:6px; }
    #hint{ opacity:.85; font-size:13px; margin-top:4px; line-height:1.35; }
    #stageWrap{ padding:12px; }
    /* altura estable iPhone */
    #canvas{
      width:100%;
      height: 45vh;
      min-height: 300px;
      max-height: 560px;
      background:#000;
      border-radius:12px;
      display:block;
      touch-action:none;
    }
    #err{
      padding:10px 12px; margin:12px; border-radius:10px;
      background:#ff3b30; color:#fff; display:none; white-space:pre-wrap;
    }
    .row { display:flex; gap:10px; }
    .row button { width: 100%; }
  </style>
</head>

<body>

<div id="err"></div>

<header>
  <div class="box">
    <div><b>1) Subir foto</b></div>
    <input id="file" type="file" accept="image/*">
    <div id="hint">
      • 1 dedo: marcar puntos<br>
      • 2 dedos: zoom (pinch) y mover<br>
      • Primero calibrás con una medida conocida, después medís en cm
    </div>
  </div>

  <div class="box">
    <div><b>2) Calibrar con una medida real (cm)</b></div>
    <div style="opacity:.9;font-size:13px;margin-top:4px;">
      Marcá 2 puntos sobre una distancia conocida (ej: ancho real).
    </div>
    <input id="realValue" type="number" placeholder="Ej: 200">
    <button id="setScale">Guardar escala</button>

    <div class="row">
      <button id="resetZoom">Reset zoom</button>
    </div>
  </div>

  <div class="box">
    <div><b>Resultado</b></div>
    <div id="result">Subí una foto. Luego tocá 2 puntos para calibrar.</div>
    <button id="resetPoints">Reset puntos</button>
  </div>
</header>

<div id="stageWrap">
  <canvas id="canvas"></canvas>
</div>

<script>
(() => {
  const errBox = document.getElementById('err');
  function showErr(e){
    errBox.style.display = 'block';
    errBox.textContent = 'Error: ' + (e && e.message ? e.message : String(e));
  }

  try {
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    const fileInput = document.getElementById('file');
    const realInput = document.getElementById('realValue');
    const setScaleBtn = document.getElementById('setScale');
    const resetPointsBtn = document.getElementById('resetPoints');
    const resetZoomBtn = document.getElementById('resetZoom');
    const resultEl = document.getElementById('result');

    let img = new Image();
    let imgLoaded = false;

    // Base fit (sin deformar)
    let baseScale = 1;
    let baseOffX = 0;
    let baseOffY = 0;

    // Zoom/pan del usuario
    let zoom = 1;
    let panX = 0;
    let panY = 0;

    // Puntos en coords CANVAS
    let p1 = null, p2 = null;

    // cm por pixel (en CANVAS, con el zoom ya aplicado visualmente en posiciones)
    let cmPerPx = null;

    function resizeCanvas() {
      const r = canvas.getBoundingClientRect();
      canvas.width = Math.max(1, Math.round(r.width));
      canvas.height = Math.max(1, Math.round(r.height));
      if (imgLoaded) fitImage();
      draw();
    }

    function fitImage() {
      const sx = canvas.width / img.width;
      const sy = canvas.height / img.height;
      baseScale = Math.min(sx, sy);

      const w = img.width * baseScale;
      const h = img.height * baseScale;
      baseOffX = (canvas.width - w) / 2;
      baseOffY = (canvas.height - h) / 2;
    }

    function currentScale(){
      return baseScale * zoom;
    }

    function imageRectOnCanvas(){
      const s = currentScale();
      const w = img.width * s;
      const h = img.height * s;
      const x = baseOffX + panX;
      const y = baseOffY + panY;
      return {x,y,w,h};
    }

    function insideImage(p){
      if(!imgLoaded) return false;
      const r = imageRectOnCanvas();
      return (p.x >= r.x && p.x <= r.x + r.w && p.y >= r.y && p.y <= r.y + r.h);
    }

    function draw() {
      ctx.clearRect(0,0,canvas.width,canvas.height);
      if(!imgLoaded) return;

      const s = currentScale();
      ctx.drawImage(img, baseOffX + panX, baseOffY + panY, img.width*s, img.height*s);

      if(p1) drawPoint(p1);
      if(p1 && p2){
        drawPoint(p2);
        drawLine(p1,p2);
        showResult();
      }
    }

    function drawPoint(p){
      ctx.fillStyle = "#ffcc00";
      ctx.beginPath();
      ctx.arc(p.x,p.y,7,0,Math.PI*2);
      ctx.fill();
    }

    function drawLine(a,b){
      ctx.strokeStyle="#2b5cff";
      ctx.lineWidth=3;
      ctx.beginPath();
      ctx.moveTo(a.x,a.y);
      ctx.lineTo(b.x,b.y);
      ctx.stroke();
    }

    function dist(a,b){
      return Math.hypot(a.x-b.x, a.y-b.y);
    }

    function showResult(){
      if(!cmPerPx){
        resultEl.textContent = "Calibrá primero: marcá 2 puntos y tocá “Guardar escala”.";
        return;
      }
      const cm = dist(p1,p2) * cmPerPx;
      resultEl.textContent = cm.toFixed(1) + " cm";
    }

    function clamp(v, min, max){ return Math.max(min, Math.min(max, v)); }

    // Cargar imagen (iPhone safe)
    fileInput.addEventListener('change', () => {
      const f = fileInput.files && fileInput.files[0];
      if(!f) return;

      const reader = new FileReader();
      reader.onload = () => {
        const dataUrl = reader.result;
        const newImg = new Image();
        newImg.onload = () => {
          img = newImg;
          imgLoaded = true;

          // reset estado
          p1=null; p2=null; cmPerPx=null;
          zoom = 1; panX = 0; panY = 0;

          resultEl.textContent = "Imagen cargada. Tocá 2 puntos para calibrar.";
          resizeCanvas();
        };
        newImg.onerror = () => showErr("No se pudo cargar la imagen.");
        newImg.src = dataUrl;
      };
      reader.onerror = () => showErr("FileReader falló.");
      reader.readAsDataURL(f);
    });

    // Tap 1 dedo: marcar puntos
    canvas.addEventListener('click', (e) => {
      if(!imgLoaded) return;

      const r = canvas.getBoundingClientRect();
      const p = { x: e.clientX - r.left, y: e.clientY - r.top };

      if(!insideImage(p)) return;

      if(!p1) p1 = p;
      else if(!p2) p2 = p;
      else { p1 = p; p2 = null; }

      draw();
    });

    // Calibrar (regla de 3)
    setScaleBtn.addEventListener('click', () => {
      if(!p1 || !p2){
        alert("Marcá 2 puntos sobre una medida conocida primero.");
        return;
      }
      const realCm = Number(realInput.value);
      if(!realCm || realCm <= 0){
        alert("Ingresá una medida real en cm (ej: 200).");
        return;
      }
      cmPerPx = realCm / dist(p1,p2);
      resultEl.textContent = "Escala guardada. Ahora medí tocando 2 puntos.";
      draw();
    });

    resetPointsBtn.addEventListener('click', () => {
      p1=null; p2=null;
      resultEl.textContent = "Puntos reseteados. Tocá 2 puntos.";
      draw();
    });

    resetZoomBtn.addEventListener('click', () => {
      zoom = 1; panX = 0; panY = 0;
      draw();
    });

    // ====== Pinch zoom + pan con 2 dedos (iPhone) ======
    let lastDist = null;
    let lastCenter = null;

    function getDist(t1, t2) {
      return Math.hypot(t1.clientX - t2.clientX, t1.clientY - t2.clientY);
    }
    function getCenter(t1, t2) {
      return { x: (t1.clientX + t2.clientX)/2, y: (t1.clientY + t2.clientY)/2 };
    }

    canvas.addEventListener('touchstart', (e) => {
      if (e.touches.length === 2) {
        lastDist = getDist(e.touches[0], e.touches[1]);
        lastCenter = getCenter(e.touches[0], e.touches[1]);
      }
    }, { passive: true });

    canvas.addEventListener('touchmove', (e) => {
      if (e.touches.length === 2) {
        e.preventDefault();

        const distNow = getDist(e.touches[0], e.touches[1]);
        const centerNow = getCenter(e.touches[0], e.touches[1]);

        // Zoom
        if (lastDist) {
          const factor = distNow / lastDist;

          // Zoom alrededor del centro (mantenerlo “debajo de los dedos”)
          const rect = canvas.getBoundingClientRect();
          const cx = centerNow.x - rect.left;
          const cy = centerNow.y - rect.top;

          // Ajuste pan para que el zoom sea sobre el punto del canvas
          const prevScale = currentScale();
          zoom = clamp(zoom * factor, 1, 6);
          const newScale = currentScale();

          // Para mantener el punto fijo: pan += (p - center) * (1 - new/old)
          panX += (cx - (baseOffX + panX)) * (1 - newScale / prevScale);
          panY += (cy - (baseOffY + panY)) * (1 - newScale / prevScale);
        }

        // Pan (mover con el centro)
        if (lastCenter) {
          panX += (centerNow.x - lastCenter.x);
          panY += (centerNow.y - lastCenter.y);
        }

        lastDist = distNow;
        lastCenter = centerNow;

        draw();
      }
    }, { passive: false });

    canvas.addEventListener('touchend', () => {
      lastDist = null;
      lastCenter = null;
    });

    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

  } catch(e){
    showErr(e);
  }
})();
</script>

</body>
</html>
